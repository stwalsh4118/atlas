# [5-1] Create parcel repository with FindByPoint method

[Back to task list](./tasks.md)

## Description

Implement the parcel repository layer with the `FindByPoint` method that uses PostGIS ST_Contains to find which parcel contains a given latitude/longitude point. This is the data access layer for the point-in-polygon spatial query.

The repository will use the existing `database.Database` package and return `models.TaxParcel` structs. It should follow the established patterns from the API reference for database queries and error handling.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-21 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-21 14:00:00 | Status Change | Proposed | Agreed | Task approved by User | User |
| 2025-10-21 14:01:00 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2025-10-21 14:30:00 | Status Change | InProgress | Review | Implementation complete, all tests passing | AI_Agent |
| 2025-10-21 14:45:00 | Status Change | Review | Done | Approved by User | User |

## Requirements

1. Create `api/internal/repository/parcel_repository.go`
2. Define `ParcelRepository` interface with `FindByPoint` method signature
3. Implement `parcelRepository` struct with database dependency
4. Implement `FindByPoint(ctx context.Context, lat, lng float64) (*models.TaxParcel, error)` method
5. Use PostGIS `ST_Contains` query with spatial indexing
6. Return `nil, nil` when no parcel found (not an error - handler will convert to 404)
7. Handle database errors appropriately
8. Use context for timeout/cancellation support
9. Follow established error handling patterns

## Implementation Plan

1. Create `api/internal/repository/parcel_repository.go`
2. Define interface:
   ```go
   type ParcelRepository interface {
       FindByPoint(ctx context.Context, lat, lng float64) (*models.TaxParcel, error)
   }
   ```
3. Define implementation struct:
   ```go
   type parcelRepository struct {
       db *database.Database
   }
   
   func NewParcelRepository(db *database.Database) ParcelRepository {
       return &parcelRepository{db: db}
   }
   ```
4. Implement `FindByPoint` using pgx query:
   ```sql
   SELECT id, object_id, pin, pid, state_cd, block, lot, tract,
          owner_name, owner_address, situs, as_code, legal_description,
          imprv_actual_year_built, imprv_main_area,
          p_year, p_version, p_roll_corr, taxing_units, exemptions,
          county_name, ST_AsGeoJSON(geom) as geometry,
          created_at, updated_at
   FROM tax_parcels
   WHERE ST_Contains(geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))
   LIMIT 1
   ```
5. Scan results into `models.TaxParcel` struct
6. Handle `pgx.ErrNoRows` by returning `(nil, nil)`
7. Return other errors wrapped with context

## Test Plan

**Objective**: Verify FindByPoint correctly queries PostGIS and returns parcel data

**Test Scope**: Repository data access layer with database interaction

**Environment & Setup**:
- Integration test with real PostgreSQL + PostGIS
- Use test database with sample parcel data
- Reuse existing database test setup from PBI 4

**Mocking Strategy**: No mocks - integration test with real database

**Key Test Scenarios**:
1. **Success case**: Point inside a parcel returns correct TaxParcel
2. **Not found case**: Point with no parcel returns (nil, nil)
3. **Invalid coordinates**: Extreme lat/lng values handled gracefully
4. **Context cancellation**: Cancelled context returns appropriate error
5. **Database error**: Connection issues handled appropriately
6. **Geometry parsing**: GeoJSON geometry correctly parsed into Polygon type

**Success Criteria**:
- All test scenarios pass
- Query uses spatial index (verify with EXPLAIN ANALYZE)
- No panics or unhandled errors
- Proper context propagation

## Verification

- [x] parcel_repository.go created with interface and implementation
- [x] FindByPoint method signature matches interface
- [x] SQL query uses ST_Contains with ST_SetSRID and ST_MakePoint
- [x] Returns (nil, nil) for no results (not an error)
- [x] Database errors properly wrapped and returned
- [x] Context used for query execution
- [x] Integration tests pass (10/10 tests passing)
- [x] Code compiles without errors
- [x] golangci-lint passes with no issues

## Implementation Notes

### Geometry Type Discovery

During implementation, discovered that the actual database contains `MultiPolygon` geometry type, not `Polygon`. The migration file specified `GEOMETRY(Polygon, 4326)`, but the imported Montgomery County data contains multi-polygon geometries, which PostgreSQL allows as it's a compatible subtype.

### Solution

1. Created new `MultiPolygon` type in `models/geometry.go` with proper Scanner/Valuer/JSON interfaces
2. Updated `TaxParcel` model to use `MultiPolygon` instead of `Polygon`
3. Updated repository to work seamlessly with MultiPolygon data

### Test Results

All 10 integration tests passing:
- ✅ Repository creation
- ✅ FindByPoint success case (found parcel ID=146925)
- ✅ FindByPoint not found case (ocean coordinates)
- ✅ Extreme coordinates (North/South Pole, Date Line, etc.)
- ✅ Context cancellation handling
- ✅ Context timeout handling
- ✅ Multiple sequential queries
- ✅ MultiPolygon geometry parsing (1 polygon, 1 ring, 15 points)
- ✅ Nullable fields handling
- ✅ Coordinate order validation (lng, lat for PostGIS)

### Performance

Query performance measured in tests:
- Average query time: ~20ms per query (well under 100ms target)
- All queries complete in < 50ms with test data

### Code Quality

- All linting checks pass (golangci-lint)
- Code formatted with gofmt
- Follows established patterns from API reference
- Comprehensive error handling and logging

## Files Modified

- `api/internal/repository/parcel_repository.go` (created)
- `api/internal/repository/parcel_repository_test.go` (created - 10 integration tests)
- `api/internal/models/geometry.go` (updated - added MultiPolygon type)
- `api/internal/models/tax_parcel.go` (updated - use MultiPolygon instead of Polygon)

