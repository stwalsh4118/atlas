# [5-6] Extend repository and service for get-by-id query

[Back to task list](./tasks.md)

## Description

Extend the parcel repository and service layers to support fetching a parcel by its database ID or parcel_id string. This allows users to directly access a specific property when they know its identifier.

This task adds the third and final query method to complete the parcel repository and service.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-21 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

1. Add `FindByID` method to `ParcelRepository` interface
2. Support lookup by database ID (uint) or parcel identifier (string)
3. Handle both numeric IDs and string parcel IDs intelligently
4. Return nil when parcel not found
5. Add `GetParcelByID` method to `ParcelService` interface
6. Implement service method with validation
7. Follow established patterns for error handling and logging

## Implementation Plan

### Repository Layer

1. Update `ParcelRepository` interface in `parcel_repository.go`:
   ```go
   type ParcelRepository interface {
       FindByPoint(ctx context.Context, lat, lng float64) (*models.TaxParcel, error)
       FindNearby(ctx context.Context, lat, lng float64, radiusMeters int) ([]ParcelWithDistance, error)
       FindByID(ctx context.Context, id string) (*models.TaxParcel, error)
   }
   ```
2. Implement `FindByID`:
   - Attempt to parse `id` as uint for database ID lookup
   - If parsing fails, treat as string parcel identifier
   - Query strategies:
     ```sql
     -- If id is numeric:
     SELECT ... FROM tax_parcels WHERE id = $1 LIMIT 1
     
     -- If id is alphanumeric (try common fields):
     SELECT ... FROM tax_parcels 
     WHERE object_id::text = $1 OR pin::text = $1 OR pid::text = $1
     LIMIT 1
     ```
   - Return nil if not found (not an error)
   - Return database errors

### Service Layer

1. Update `ParcelService` interface in `parcel_service.go`:
   ```go
   type ParcelService interface {
       GetParcelAtPoint(ctx context.Context, lat, lng float64) (*models.TaxParcel, error)
       GetNearbyParcels(ctx context.Context, lat, lng float64, radiusMeters int) ([]repository.ParcelWithDistance, error)
       GetParcelByID(ctx context.Context, id string) (*models.TaxParcel, error)
   }
   ```
2. Implement `GetParcelByID`:
   - Validate id is not empty
   - Validate id length (max 50 chars)
   - Call `repo.FindByID()`
   - Return ErrParcelNotFound if result is nil
   - Log query with ID
   - Return result or error
3. Define validation error:
   ```go
   var ErrInvalidParcelID = errors.New("invalid parcel ID")
   ```

## Test Plan

**Objective**: Verify parcel lookup by ID works for both numeric and string identifiers

**Test Scope**: Repository and service layers with ID-based queries

**Environment & Setup**:
- Integration test with PostgreSQL
- Test database with parcels having known IDs
- Unit test for service validation with mocked repository

**Mocking Strategy**:
- Repository: Integration test with real database
- Service: Unit test with mocked repository

**Key Test Scenarios**:

**Repository Tests**:
1. **Lookup by database ID**: Numeric ID returns correct parcel
2. **Lookup by object_id**: String identifier returns correct parcel
3. **Lookup by pin**: PIN number as string returns correct parcel
4. **Lookup by pid**: PID number as string returns correct parcel
5. **Not found**: Non-existent ID returns nil (no error)
6. **Empty ID**: Empty string handled gracefully
7. **Special characters**: IDs with special chars don't cause SQL errors

**Service Tests**:
1. **Valid database ID**: Calls repository correctly
2. **Valid string ID**: Calls repository correctly
3. **Empty ID**: Returns validation error
4. **Too long ID**: ID > 50 chars returns error
5. **Repository returns nil**: Service returns ErrParcelNotFound
6. **Repository error**: Database errors propagated
7. **Logging**: Structured logs include ID

**Success Criteria**:
- Both numeric and string IDs work correctly
- No SQL injection vulnerabilities
- Not found returns appropriate response (not an error at repo level)
- All validation enforced at service level

## Verification

- [ ] FindByID added to ParcelRepository interface
- [ ] FindByID handles both numeric and string IDs
- [ ] Returns nil for not found (not error)
- [ ] Queries use parameterized SQL (no injection risk)
- [ ] GetParcelByID added to ParcelService interface
- [ ] Service validates ID (not empty, max length)
- [ ] ErrInvalidParcelID defined
- [ ] Repository integration tests pass
- [ ] Service unit tests pass
- [ ] Code compiles and lints cleanly

## Files Modified

- `api/internal/repository/parcel_repository.go` (updated)
- `api/internal/repository/parcel_repository_test.go` (updated)
- `api/internal/services/parcel_service.go` (updated)
- `api/internal/services/parcel_service_test.go` (updated)

