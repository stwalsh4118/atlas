# [4-6] Implement health check endpoints

[Back to task list](./tasks.md)

## Description

Create HTTP handlers for health check endpoints including a basic health check and a readiness check that verifies database connectivity. These endpoints will be used by monitoring systems and load balancers.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-21 00:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-21 02:00:00 | Status Change | Proposed | Agreed | Task approved and ready to implement | User |
| 2025-10-21 02:00:01 | Status Change | Agreed | InProgress | Starting health check handler implementation | AI_Agent |
| 2025-10-21 02:30:00 | Status Change | InProgress | Review | Health handlers implemented with comprehensive tests | AI_Agent |
| 2025-10-21 03:00:00 | Status Change | Review | Done | Task completed and approved | User |

## Requirements

1. Create handlers package in internal/handlers/
2. Implement GET /health endpoint (basic health check)
   - Returns 200 OK with {"status": "healthy"}
   - Does not check dependencies
3. Implement GET /health/ready endpoint (readiness check)
   - Checks database connectivity
   - Returns 200 OK if database is connected
   - Returns 503 Service Unavailable if database is down
   - Response: {"status": "ready", "database": "connected"}
4. Implement GET /api/v1/info endpoint
   - Returns API metadata (version, uptime, environment)
5. Handle errors gracefully
6. Use structured logging for health check failures

## Implementation Plan

1. Create `api/internal/handlers/health.go`
2. Define HealthHandler struct:
   ```go
   type HealthHandler struct {
       db     *database.Database
       logger *logger.Logger
       startTime time.Time
   }
   ```
3. Implement NewHealthHandler() constructor
4. Implement Health() handler:
   - Always return 200 OK
   - JSON response: {"status": "healthy"}
5. Implement Ready() handler:
   - Call db.Ping() to check connectivity
   - Return 200 if ping succeeds
   - Return 503 if ping fails
   - JSON response with database status
   - Log failures
6. Implement Info() handler:
   - Calculate uptime since startTime
   - Return version (read from const or env)
   - Return environment
   - JSON response with all metadata
7. Add constants for version info
8. Create helper functions for JSON responses

## Test Plan

**Objective**: Verify health check endpoints work correctly with and without database connectivity

**Test Scope**: Health, readiness, and info endpoints with various database states

**Key Test Scenarios**:
1. /health always returns 200 OK
2. /health/ready returns 200 when database is connected
3. /health/ready returns 503 when database is unavailable
4. /health/ready response includes database status
5. /api/v1/info returns correct metadata (version, uptime, env)
6. All endpoints return valid JSON
7. Errors are logged appropriately

**Success Criteria**:
- Health endpoint always succeeds
- Readiness endpoint reflects actual database state
- Info endpoint returns accurate metadata
- Unit tests with mocked database
- Integration tests with real database
- Both test suites pass

## Verification

- [x] health.go created with HealthHandler
- [x] Health() handler implemented
- [x] Ready() handler implemented with database ping
- [x] Info() handler implemented with metadata
- [x] Version constant defined
- [x] JSON response structures defined
- [x] Error handling implemented
- [x] Logging added for failures (using logger from context via middleware)
- [x] Unit tests created for:
  - Health endpoint
  - Ready endpoint (DB connected)
  - Ready endpoint (DB disconnected)
  - Info endpoint
  - Response JSON serialization
  - Format uptime helper function
  - Constructor and constants
- [x] Integration tests with real database
- [x] All tests pass (unit tests: 57.9% coverage, integration tests skip gracefully when DB not configured)

## Implementation Notes

- **HealthHandler struct**: Stores database reference, start time for uptime calculation, and environment
- **Logger from context**: Uses `middleware.GetLogger(c)` to get request-scoped logger with request ID instead of storing logger in handler struct
- **Health endpoint**: Always returns 200 OK with `{"status":"healthy"}` - does not check dependencies
- **Ready endpoint**: Checks database connectivity with 2-second timeout, returns 200 if connected, 503 if not
- **Info endpoint**: Returns API version (constant), environment, and formatted uptime
- **Uptime formatting**: Human-readable format (e.g., "3d 5h 30m 15s" or "2h 15m 45s")
- **Error handling**: Logs database ping failures with timeout context
- **Test coverage**: 57.9% unit test coverage with comprehensive test scenarios
- **Integration tests**: Full integration tests with real database, skip gracefully when DB not configured
- **Dependencies**: Added testify/assert and testify/require for better test assertions

## Files Modified

- `api/internal/handlers/health.go` (new)
- `api/internal/handlers/health_test.go` (new)
- `api/test/integration/health_integration_test.go` (new)
- `api/go.mod` (updated with testify dependency)
- `api/go.sum` (updated with testify and transitive dependencies)

